\subsection{Snooze}
\label{subsec:snooze}

\AL[MS]{1.5 pages}

We now present the Snooze framework for VM
management~\cite{feller:ccgrid12} as a third case study of how
to implement and simulate advanced algorithms.

\subsubsection{Overview}

We first briefly present the Snooze architecture summarizing its main
characteristics from its presentation~\cite{feller:ccgrid12} and
additional info stemming from personal communications of the Snooze
developers and its implementation~\cite{snoozedev14,snoozeweb}.

\paragraph{Architecture}

Snooze harnesses a hierarchical architecture in order to support load
balancing and fault tolerance. At the top of the hierarchy, a
\emph{group leader (GL)} centralizes information about the whole
cluster by keeping summary information about all \emph{group managers
  (GMs)} that constitute the intermediate layer of the hierarchy. GMs
manage a number of \emph{local controllers (LCs)}, each of which
represent a node in a cluster and manage the VMs assigned to that
node. During execution, higher level components periodically send
heartbeats to lower-level components; monitoring information, \eg on
the system load, is also sent periodically in the opposite
direction. In order to propagate information down the hierarchy,
Snooze relies on hardware support for multicast
communication. Finally, a number of replicated entry points allows
clients to contact the GL, \eg in order to submit new VMs for
integration into the system.

\paragraph{Algorithms}

Apart from the handling of faults (described below), two types of
algorithms are of major importance for the administration of the
Snooze architecture: the algorithms that enable components to
dynamically enter the system and the algorithms that propagate info
between the components.

A GL is created, if it does not exist, by promotion of a GM that is
selected according to some leader election algorithm. When a GM joins
a cluster, it starts listening on a predefined channel for the
heartbeat of the GL and registers once it has received the
heartbeat. New LCs first also wait for the GL heartbeat, request a GM
assignment from the GL and register at the GM assigned to them.

Information that is passed within the system consists in periodic
heartbeat message from the GL, GMs and LCs as well as, also periodic,
charge information from LCs sent to their respective GMs and summary
charge info sent by GMs to the GL.


\paragraph{Fault tolerance} 

GLs, GMs and LCs may fail during the system execution. System
components identify that a node on the corresponding higher-level node
has failed (the GL in case of a GM, a GM in the case of an LC) in an
asynchronous fashion through the lack of heartbeat messages.

In the case of a GL failure, one of the GMs becomes the new GL, stops
its GM activities and prevents the LCs it manages so that they can
start rejoining the system. If a GM fails, the GL and the LCs it has
managed will become aware of it based on the lack of heartbeats,
update its data structures and, for the LCs, rejoin the system. If an
LC fails, its GM will finally learn of it due to the missing heartbeat
and charge information of the LC. The GM will then remove the LC from
its data structures.

\subsubsection{Simulation with Simgrid}

Snooze can be simulated using our model and tool support in a direct
and natural manner.

\begin{itemize}
  \item Representation of GLs, GMs, LCs
  \item Multicast node
  \item Multi-threading
  \item Reaction to faults
\end{itemize}

\subsubsection{Variants}

It is also possible to quite simply implement and simulate variants of
the Snooze model that we have simulated. These variants represent
interesting non-trivial evolutions of the original Snooze model that
have not been explored as part of Snooze. Concretely, we present the
following evolutions:

\begin{itemize}
  \item \textbf{Periodic vs.\ reactive scheduling:} 
  \item \textbf{Load balancing:} Snooze's implementation assigns LCs
    in a round-robin fashion. We can simply implement simulate other
    asignment schemes, e.g., load balancing schemes.
  \item \textbf{Variants of join algorithms:}
    \begin{itemize}
      \item \textbf{GMs rejoin on GM entry:} The Snooze
        paper~\cite{feller:ccgrid12} states that all GMs should rejoin if a new
        GMs enters the system (perhaps for load balancing). This is
        implemented in the Snooze simulation. However, this strategy
        makes the system instable, because of frequent joins of GMs
        that are not available during a relatively long
        time. Furthermore, this entails joins of many LCs. Overall
        this strategy seems unreasonable.
    \end{itemize}
\end{itemize}



%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
