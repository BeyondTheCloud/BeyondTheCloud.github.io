
%%%% TODO: Adrien, this subsection has been already addressed in the previous subsection, so I commented it
%\subsection{Implementation of DVMS}
%
%A prototype of DVMS leveraging the \emph{peer actor} abstraction has been 
%developed. In addition we built two versions of the network overlay actor: one 
%working with Chord, and one working with the Vivaldi based overlay. This mean 
%that now DVMS is network overlay agnostic to, and thus can be used with either
%of the network overlay without requiring any modification in it's source code.
%
%The implementation is based on modern programming language and framework such as 
%\emph{Scala} and \emph{Akka framework}. Scala is a language that mixes object
%oriented programming with functional programming, it's compiler produces 
%\emph{Java bytecode} which can be run in any JVM environment. Combining Scala 
%with Akka enabled us to take advantage of advanced techniques for concurrent 
%programming such as \emph{future/promise} and \emph{actor model}, and to benefit
%from Java ease of deployment.
%


%\subsection{Grid'5000 experiments}

%\JP{Complete this section with more experimentation results.}

%\subsubsection{Objectives}
%The prototype has been tested with a various number of experiments conducted on
%the Grid'5000 testbed. 
The main objective of the experiments we conducted was to estimate
impact of locality on the performance of a distributed scheduling algorithm. 
A significant portion of the reconfiguration time is spent in live migration of
virtual machines, which depends of network parameters such as latency and
bandwidth. One way to improve performance of distributed scheduling algorithm is
is to promote collaboration between close ressources, which can be reach by 
maximising this ratio: $nb\ intrasite\ migrations/nb\ migrations$.
%\[
%	\frac{number\ of\ intrasite\ migrations}{number\ of\ migrations}
%\]


\subsection{Experimental protocol}
To compare our experiments, we implemented a dedicated injector that makes load
changes of VMs during a predefined time.  VMs are launched on PMs in a
round-robin manner, \ie each PM has almost the same number of VMs at the
beginning, The experiment consists in  repeatedly changes target CPU loads of
VMs.  Every $t$ second, the injector that is deployed on a dedicated node,
selects one VM and changes its CPU load according to a Gaussian distribution.
$t$ is a random variable that follows an exponential distribution with rate
parameter $\lambda$. The Gaussian distribution is defined by a mean ($\mu$) as
well as a standard deviation ($\sigma$) that are given at the beginning of the
experiment. 
exponential and the Gaussian distributions previously described. 
The parameters are $\lambda=\mathit{Nb\_VMs}/300$ and $\mu=70$, $\sigma=30$.
Concretely, the load of each VM starts from 0\% and varies on average every 5
min in steps of 10 (with a significant part between 40\% and 100\% of CPU
usage).   Each experiment duration was set to 3600 seconds.

For each experiment, we booked 40 compute servers spread on 4 geographical sites
and 1 service server from the Grid'5000 testbed. The compute servers were used 
to run virtual machines and DVMS while the service node runs the aforementioned
injector.
%
Each compute node will host a number of virtual machines proportional to the 
number of CPU cores it has ($nb VM\ =\ 1.3\ \times\ nb\ cores)$
%\[
%	number\ of\ virtual\ machines\ =\ 1.3\ \times\ number\ of\ cores
%\]

\subsection{Results}

The impact of locality on DVMS is significant: using a Vivaldi based network
overlay leads to an average number of 86.3\% of intrasite migrations while using 
a Chord based DVMS leads a ratio of 49.6\% of intrasite migrations, as depicted
in the table \ref{tab:nb_mig}.

\begin{table}

  \begin{center}
    \begin{tabular}{|c|c|c|}   

      % <HEADER>
      \hline \multicolumn{1}{|p{3cm}|}{ }
       & \multicolumn{1}{|p{3cm}|}{\centering Chord }  & \multicolumn{1}{|p{3cm}|}{ \centering Vivaldi}  \\
      % </HEADER>

      % <ROW 1> => Average
      \hline
      average & 0.496 & 0.863 \\
      % </ROW 1>

      % <ROW 2> => Min
      \hline
      minimum & 0.378 & 0.798 \\
      % </ROW 2>

      % <ROW 2> => Max
      \hline
      maximum & 0.629 & 0.935 \\
      % </ROW 2>

      \hline
    \end{tabular}
  \end{center}
  \caption{Comparison of intra-site migrations ratio between Chord and Vivaldi overlay.}
	\label{tab:nb_mig}
\end{table}



\begin{table}

  \begin{center}
    \begin{tabular}{|c|c|c|}   

      % <HEADER>
      \hline \multicolumn{1}{|p{3cm}|}{ }
       & \multicolumn{1}{|p{3cm}|}{\centering Chord }  & \multicolumn{1}{|p{3cm}|}{ \centering Vivaldi}  \\
      % </HEADER>

      % <ROW 1> => Average
      \hline
      mean size (servers) & 3.918 & 2.337 \\
      % </ROW 1>

      % <ROW 2> => Min
      \hline
      mean number of sites involved & 1.645 & 1.082 \\
      % </ROW 2>

      \hline
    \end{tabular}
  \end{center}
  \caption{Comparison of microcosms metrics between Chord and Vivaldi overlay.}
  \ref{tab:ms_size}
\end{table}
